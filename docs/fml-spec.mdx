---
id: fml-spec
title: The Feature Manifest Language spec
slug: /fml-spec
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";


# The Feature Manifest Language

## About this document

This document is the specfiication for the Feature Manifest Language for use with the Nimbus SDK.

Language features that have not yet been implemented are marked as so.

## Introduction

Nimbus is an experimentation platform to allow product owners to easily run experiments on their mobile apps.

The [Feature API][feature-api] allows application developers to query Nimbus for JSON objects which they could use to configure the app's features.

The Feature Manifest is a significant evolution of the Feature API: by generating Kotlin and Swift code, it adds type-safety, schema checking and defaulting to the Feature API.

## High level concepts

To the product owner, Nimbus allows you to experiment with different configurations of the application.

It does this by exposing a small proportion of the audience to different configurations of a feature. Once a winning configuration is identified, it can be rolled out to the rest of the audience, all without a re-release of the app.

To the app developer, **Nimbus is a configuration store**. Features are configured using data from Nimbus. Nimbus is updated at startup of each run.

The "Feature" in "Feature API" and "Feature Manifest" refers to configuration for a specific application feature.

The "Feature Manifest" is a schema for all the features in an app. This is used for generating type safe `struct`s and `data class`es, and a schema for Experimenter to validate the configuration during experiment setup.

The "Feature Manifest Language" is definition language for writing feature manifest.

`nimbus-fml` is the name fo the tool for processing the feature manifest, to generate Swift and Kotlin and the JSON schema that Experimenter can ingest.

Features are configured remotely by sending JSON objects to the Nimbus SDK on each device. It is the job of the `nimbus-fml`, and the code that it generates to unpack that JSON, validate it, coerce it into values usable by the app and recover if anything goes wrong.

[feature-api]: feature-variables-and-me.md

### JSON Merge Patch

For each feature, the feature manifest should define a complete configuration needed by the app, including a default value for every variable.

Remotely set experiments and rollouts will vary the configurations by presenting _patches_ on that configuration. If the complete configuration of the feature can be
represented by a JSON object, then patches to that configuration would be applied in a manner consistent with [JSON Merge Patch RFC 7396][json-merge-patch].

[json-merge-patch]: https://datatracker.ietf.org/doc/html/rfc7396

### About the generated code

Each project has its own manifest file, containing all the features configured in that project.

Running `nimbus-fml` for a manifest generates a Swift or Kotlin class, which is named as a commmand line argument.

In the examples, this class is called `FxNimbus`, but this is project specific. This is the entry point to getting values out of Nimbus.

The generated class must be connected to the Nimbus SDK, which downloads the experiment recipes and decides which experiments this user is in.

<Tabs
  defaultValue="swift"
  values={[
    { label: "Swift", value: "swift" },
    { label: "Kotlin", value: "kotlin" },
  ]
}>
<TabItem value="swift">

```swift
// Initialize the Nimbus SDK
let nimbus = createNimbusForApplication()
// Connect the generated code to the Nimbus SDK
FxNimbus.api = nimbus
```

</TabItem>
<TabItem value="kotlin">

```swift
// Initialize the Nimbus SDK
val nimbus = createNimbusForApplication()
// Connect the generated code to the Nimbus SDK
FxNimbus.api = nimbus
```

</TabItem>
</Tabs>

Feature configuration for each feature are accessed through the `FxNimbus.features` property. For example, a `newtab` feature's configuration can be accessed thus:

<Tabs
  defaultValue="swift"
  values={[
    { label: "Swift", value: "swift" },
    { label: "Kotlin", value: "kotlin" },
  ]
}>
<TabItem value="swift">

```swift
let newTabConfig = FxNimbus.features.newtab.value()
```

</TabItem>
<TabItem value="kotlin">

```kotlin
val newTabConfig = FxNimbus.features.newtab.value()
```

</TabItem>
</Tabs>

> Details:
> When the `value()` method is called:
>
> * the Nimbus `api` is queried to get a JSON object for the feature with id of `newtab`
> * the result is used to construct an instance of `Newtab`, which is generated by the FML
> * the `Newtab` object merges its default values with the values from the JSON.

You should record when the user has been exposed to the feature or exposed to where the feature would've been.

<Tabs
  defaultValue="swift"
  values={[
    { label: "Swift", value: "swift" },
    { label: "Kotlin", value: "kotlin" },
  ]
}>
<TabItem value="swift">

```swift
FxNimbus.features.newtab.recordExposure()
```

</TabItem>
<TabItem value="kotlin">

```kotlin
FxNimbus.features.newtab.recordExposure()
```

</TabItem>
</Tabs>

### Identifier cases

All the examples below use `kebab-case` for identifiers. When these identifiers are used to generate code, they are transformed to the language-specific casing. For example, a feature is specified in the FML as being called `spotlight-search`, but would be referred to in Swift as `spotlightSearch`.

## Introducing the FML

The [Feature Manifest Language is a dialect of YAML][fml-is-yaml]. The manifest file, say `nimbus.fml.yaml` must be valid YAML.

YAML was chosen, in part, because it allows comments, there are many high quality parsers, and is a superset of JSON; JSON is used extensively in the configuration of features.

[fml-is-yaml]: fml-front-end-format.md

At a minimum the `nimbus.fml.yaml` file defines a map of features.

```yaml
# A YAML file to define Nimbus features.
# This file has zero features.
features: {}
```

This `features` property is a mapping of feature-id to feature. Feature IDs need to be valid strings. In this document all feature IDs are `kebab-cased` in the manifest.

Adding features to this object will automatically be picked up by Experimenter.

They are converted to `mixedCamelCase` in both Kotlin and Swift.

### Features have `variables`

We start with an example which configures the integration between Firefox for iOS and iOS Spotlight feature.

Here, we define a feature with an id of `spotlight-search`, with two variables— `enabled` and `max-age-in-days`

```yaml
features:
  spotlight-search:
    description: Configuring how we integrate web-pages with iOS's Spotlight search
    variables:
      enabled:
        description: If `false`, the app will not record anything with Spotlight.
        type: Bool
        default: false
      max-age-in-days:
        description: The number of days a single piece of content is indexed for.
        type: Double
        default: 28.0
```

Each variable has a `description`, a `type` and `default` value.

The `description` is copied verbatim into the generated code as comments. This will be visible in Xcode and Android Studio when navigating code or code completions.

The `type` is the type name or type label that the variable will be. The type labels for variables will be familiar to developers who have written Kotlin, Swift or Typescript. The different types of types, are discussed in detail below.

The `default` value is used when the variable is not set remotely, or there is a problem within the SDK.

The default value has to make sense in the context of the variable's type.

```swift
let spotlightConfig = FxNimbus.features.spotlightSearch.value()
guard spotlightConfig.enabled else {
    return
}

// let item = CSSearchableItem(…)

let oneDayInSeconds: TimeInterval = 24 * 60 * 60
let maxAgeInSeconds = spotlightConfig.maxAgeInDays * oneDayInSeconds
item.expirationDate = Date(timeIntervalSinceNow: maxAgeInSeconds)
```

Notice that:

* the feature configuration is accessible from `FxNimbus.features.spotlightSearch.value()`
* the feature id and variable names have been transformed to the Swift formatting convention; in this case both to mixed-camel-case.
* the values consumed by Swift are non-optional.

The generated code includes the defaults. It does not need to call into the Nimbus runtime or access the network.

<Tabs
  defaultValue="swift"
  values={[
    { label: "Swift", value: "swift" },
    { label: "Kotlin", value: "kotlin" },
  ]
}>
<TabItem value="swift">

```swift
struct SpotlightSearch {
    private let variables: Variables?

    init(variables: Variables? = nil) {
        self.variables = variables
    }

    lazy var enabled: Bool = {
        self.variables?.getBool("enabled") ?? false
    }()

    lazy var keepNumDays: Double = {
        self.variables?.getDouble("enabled") ?? 28.0
    }()
}
```

</TabItem>
<TabItem value="kotlin">

```kotlin
data class SpotlightSearch(private val variables: Variables? = null) {
    var enabled: Bool by lazy {
        self.variables?.getBool("enabled") ?? false
    }

    var keepNumDays: Double by lazy {
        self.variables?.getDouble("enabled") ?? 28.0
    }
}
```

</TabItem>
</Tabs>

Variables are evaluated lazily.

### Enumerations

Using the same `spotlight-search` feature from above. We notice that the we can include an icon in the search results.

However, we have some options around what to include, but we're not sure which is best.

```yaml
features:
  spotlight-search:
    description: "Configuring how we integrate web-pages with iOS's Spotlight search"
    variables:
      # … other variables omitted for clarity
      item-thumbnail:
        description: "The icon that appears in the Spotlight search results.
          Note that changing this does not change already indexed content."
        type: ThumbnailType
        default: letter
types:
  ThumbnailType:
    description: An enum of types of icon that can be presented alongside titles of pages
    variants:
      letter: A rendering of the first letter of the domain name
      screenshot: A screenshot thumbnail of the webppage
      favicon: The favicon derived from the webpage
      none: No icon is displayed
```

The value `itemThumbnail` is of type `ThumbnailType`, which is generated as an enum. This can be used exhaustively matched in a `switch` statement.


<Tabs
  defaultValue="swift"
  values={[
    { label: "Swift", value: "swift" },
    { label: "Kotlin", value: "kotlin" },
  ]
}>
<TabItem value="swift">

```swift
switch spotlightConfig.itemThumbnail {
    case .favicon:
        item.thumbnailData = FaviconFetcher.getFaviconFromDiskCache(imageKey: baseDomain)?.pngData()
    case .letter:
        item.thumbnailData = FaviconFetcher.letter(forUrl: url).pngData()
    case .screenshot:
        item.thumbnailData = tab.screenshot?.pngData()
    case .none:
        item.thumbnailData = nil
}
```

</TabItem>
<TabItem value="kotlin">

```kotlin
item.thumbnail = when (spotlightConfig.itemThumbnail) {
    ThumbnailType.FAVICON ->
        FaviconFetcher.getFaviconFromDiskCache(imageKey: baseDomain)
    ThumbnailType.LETTER -> FaviconFetcher.letter(forUrl: url)
    ThumbnailType.SCREENSHOT -> tab.screenshot
    ThumbnailType.NONE -> null
}
```

\* this Spotlight API doesn't exist on Android; this code is illustrating the enums on the lefthand side of the `case` clauses in the `when` expression.

</TabItem>
</Tabs>

Note that enumeration variants in Swift are in `mixedCamelCase`; in Kotlin they are in `SCREAMING_SNAKE_CASE`.

## Feature defaults

Already, in this simple example we have three variables. We may want to vary the configuration of the feature when the user is not involved in an experiment.

This might be because we have run an experiment and learned that a change of configuration should be made more permanent.

The `defaults` list is a list of zero or more "default blocks", used to patch the default values of the variables in a feature.

The `value` property defines the patch which is overlaid on top of the existing variable values.

```yaml
features:
  spotlight-search:
    variables:
      enabled:
        description: If `false`, the app will not record anything with Spotlight.
        type: Bool
        default: false
      max-age-in-days:
        description: The number of days a single piece of content is indexed for.
        type: Double
        default: 28.0
      item-thumbnail:
        description: "The icon that appears in the Spotlight search results.
          Note that changing this does not change already indexed content."
        type: ThumbnailType
        default: letter
    defaults:
      - value: { item-thumbnail: screenshot, max-age-in-days: 56.0 }
```

The `defaults` list of `value`s set the default value of `item-thumbnail` to `screenshot`, and `max-age-in-days` to `56.0`.

Adding new feature blocks to the `defaults` list patches the existing defaults further:

```yaml
    defaults:
      - value: { item-thumbnail: screenshot, max-age-in-days: 56.0 }
      - value: { max-age-in-days: 64.0 }
```

In this case, the default value for `item-thumbnail` is now `screenshot`, and `max-age-in-days` is `64.0`.

### Feature defaults and channels

Sometimes it is useful to have different default configurations for different _channels_ of an application. For example, you may want to have a feature available for testing on Nightly or Beta before turning it on in Release.

This is achieved by declaring `channels` in the manifest.

```yaml
channels:
  - nightly
  - beta
  - release
features:
  spotlight-search:
    variables:
      enabled:
        description: "…"
        type: Bool
        default: false
    defaults:
      - channel: nightly
        value: { enabled: true }
```

The `channel` property specifies which build flavour the default applies. In this example, the `nightly` version of the app set the `enabled` variable to `true`; all other versions of the app have `enabled` as `false`.

In this way, app developers can use the feature manifest as a replacement for other more adhoc feature flag solutions.

### Feature defaults and runtime targeting

> ⚠️ Unimplemented. This is intended to use the same JEXL targeting used elsewhere in Nimbus SDK.

Occassionally, we would like to vary a configuration based upon the device. In this example, the `homepage` feature has sections for both Pocket and Topsites.

```yaml
features:
  homepage:
    variables:
      pocket-enabled:
        description: If true, show stories from Pocket. This is only available in certain territories.
        type: Bool
        default: false
      topsites-enabled:
        description: If true, show tiles from the users most recent and frequently visited pages.
        type: Bool
        default: false
    defaults:
      - channel: nightly
        value: { topsites-enabled: true }
      - channel: nightly
        targeting: locale in ['en-US', 'de-DE', 'en-GB']
        value: { pocket-enabled: true }
```

In this example, `pocket-enabled` defaults to `true` only on the `nightly` channel and when the device locale is in `US`, `DE` or `GB`.

## Additional types

### Primitive types

Primitive types supported:

 * `String` or `string`
 * `Boolean`, `Bool` or `boolean`. Both Kotlin and Swift's spelling is supported.
 * `Int` or `integer`.


### Types coerced from `String`

> ⚠️ Unimplemented.

We have already seen enums being declared in the `types` section of the manifest.

Other types that may be derived from `String`:

 * `Color`
 * `URL`

### Suggested values

> ⚠️ Unimplemented. This is implemented in the `Variables` API however is not exposed by the FML due to an uncertain syntax.
> Comment definitely welcome.

Strings that can be coerced to resources within the bundle; however they are error prone to type in the Experimenter interface.

Suggested values can be used to suggest values to the experiment owner, with a description on what the resource will look like.

 * `Text` performs a lookup for displayable text in the application bundle. If not text exists, returns the string used for lookup.
 * `Image` performs a lookup for an image in the application bundle.

For each of these types, the default value *must* correspond to a valid resource identifier in the app.

```yaml
features:
    upgrade-message:
        description: A message displayed when the user upgrades
        variables:
            hero-image:
                description: A pre-bundled image
                type: Image
                default: ic_fox
                suggested:
                  ic_fox: A picture of a cute fox
                  ic_snow_fox: A picture of a cute snow fox
                  ic_redpanda: A picture of a cute red panda
            message-content:
                description: Text content to show the user
                default: msg_thankyou
                suggested:
                  msg_welldone: A nice well done for upgrading
                  msg_thankyou: A nice thank you for sticking with us
                  msg_warning: A warning that bad things happen to good people
```

### Object types

Some features require more organization. In the case, JSON Objects can be coerced into generated data classes.

Object types have fields in the same way features have variables. Objects can be used in multiple places, and in more than one feature.

```yaml
features:
  dialog-appearance:
    description: A feature to vary the appearance of all toasts and modal dialogs
    variables:
      positive-button:
        type: DialogButton
        default:
          background-color: blue
          text-color: white
      neutral-button:
        type: DialogButton
        default: {}
      negative-button:
        type: DialogButton
        default:
          text-color: white
          background-color: red
types:
  DialogButton:
    description: A button used in dialogs throughout the app
    fields:
      text-color:
        description: The color of the text
        type: String
        default: black
      background-color:
        description: The background color
        type: String
        default: gray
```

The JSON to recreate the defaults for the feature above would be:

```json
{
  "positive-button": {
    "text-color": "blue",
    "background-color": "white"
  },
  "neutral-button": {
    "text-color": "black",
    "background-color": "gray"
  },
  "negative-button": {
    "text-color": "red",
    "background-color": "white"
  }
}
```

### Structural types

Generic types aren't supported, but in the following section, `T` can be any other type supported by the FML, including structural types.

 * `Option<T>` or `T?`
 * `List<T>` or `[T]` - lists of type `T`. Lists are encoded with JSON arrays.
    Lists are not merged, so are less useful than you might think.
 * `Map<K, V>` or `[K: V]` — maps with key type `K` to `V`.

Maps are transported as JSON objects, which restrict the types of the keys to types that can be coerced from `String`s. Additionally, JSON values that cannot be coerced to the value type of the map are discared.

```yaml
features:
  homepage:
    variables:
      sections-enabled:
        description: A map of whether or not to display the sections.
        type: Map<SectionId, Boolean>
        default:
          top-sites: true
          jump-back-in: false
          pocket: false
          recently-saved: false
          recent-searches: false
      section-ordering:
        description: The order that the sections appear in on the homescreen.
        type: List<SectionId>
        value:
          - jump-back-in
          - pocket
          - recently-saved
          - recent-searches
    defaults:
      - channel: nightly
        value:
          {
            top-sites: true,
            jump-back-in: true,
            recently-saved: true,
            recent-searches: true,
            pocket: true,
          }
      - targeting: "!(locale in ['en-US', 'en-GB', 'de-DE'])"
        value: { pocket: false }
types:
  SectionId:
    description: An enum representing the sections enabled by the homepage.
    variants:
      top-sites:
        Frecency based URLs
      jump-back-in:
        Tabs which the user was interrupted while reading.
      pocket:
        URLs from the Pocket homepage
      recently-saved:
        URLs which were recently bookmarked or saved to Pocket
      recent-searches:
        Search queries and their opened results.
```

In this example, a `Map<SectionId, Boolean>` is used. `SectionId` is an enum.

Maps with enum keys must have a default value for every variant of the enum.

Since maps are backed by JSON objects, the merge/patching allows entries to come from the manifest, experiments and rollouts simulatenously.

## Variables and fields with no defaults

### Required fields

> ⚠️ Unimplemented.

Some object fields do not have a sensible default value, but without them, the object itself doesn't make sense.

For example a `MessageItem` doesn't make sense unless it has a `message` and a `deeplink`. Where any required fields are missing from the JSON, the `MessageItem` is incomplete, and cannot be used.

Incomplete objects cannot be included in maps, lists or optional types.

In this case, a message surface is added to the `new-tab`, but isn't always needed to be displayed.

```yaml
features:
  new-tab:
    variables:
      message:
        description: An optional message
        type: MessageItem?
        default: null
types:
  MessageItem:
    description: …
    fields:
      label:
        type: String
        required: true
      deeplink:
        type: String
        required: true
```

In these cases, the app code must deal with the cases with objects that are said to be failable, because there are no defaults.

```swift
let newTabConfig = FxNimbus.features.newTab.value()

if let message = newTabConfig.message {
    // We have to check that the message exists, because the message may not exist.
    displayMessage(message.label, message.deeplink)
}

// continue configuring the new tab.
```

### Failable features

> ⚠️ Unimplemented.

Feature `variables` may also be marked as `required`. In the cases where these variables are missing, then the whole feature no longer makes sense.

Features with `required` variables must be marked as `failable`.

```yaml
features:
  emergency-startup-message:
    failable: true
    description: A message displayed to the user at start up.
      variables:
        message-content:
          description: The long form message to be displayed to the user
          type: String
          required: true
        color:
          description: The background color of the screen
          type: String
          default: red
```

Failable features are implemented as Optional. If the feature is incomplete or failed, then it is returned as `nil` or `null`.

```swift
guard let message = FxNimbus.features.emergencyStartupMessage else {
    // phew, there is no emergency message.
    return
}
```

Features with `required` variables which should be marked `failable` but aren't will produce an error.